/* tslint:disable */
/* eslint-disable */
/**
 * vocab-core API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0-SNAPSHOT
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration"
import globalAxios, {
  AxiosPromise,
  AxiosInstance,
  AxiosRequestConfig,
} from "axios"
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common"
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "./base"

/**
 *
 * @export
 * @interface CalendarDate
 */
export interface CalendarDate {
  /**
   *
   * @type {Era}
   * @memberof CalendarDate
   */
  era?: Era
  /**
   *
   * @type {number}
   * @memberof CalendarDate
   */
  year?: number
  /**
   *
   * @type {number}
   * @memberof CalendarDate
   */
  month?: number
  /**
   *
   * @type {number}
   * @memberof CalendarDate
   */
  dayOfMonth?: number
  /**
   *
   * @type {number}
   * @memberof CalendarDate
   */
  dayOfWeek?: number
  /**
   *
   * @type {boolean}
   * @memberof CalendarDate
   */
  leapYear?: boolean
  /**
   *
   * @type {number}
   * @memberof CalendarDate
   */
  hours?: number
  /**
   *
   * @type {number}
   * @memberof CalendarDate
   */
  minutes?: number
  /**
   *
   * @type {number}
   * @memberof CalendarDate
   */
  seconds?: number
  /**
   *
   * @type {number}
   * @memberof CalendarDate
   */
  millis?: number
  /**
   *
   * @type {number}
   * @memberof CalendarDate
   */
  fraction?: number
  /**
   *
   * @type {boolean}
   * @memberof CalendarDate
   */
  normalized?: boolean
  /**
   *
   * @type {TimeZone}
   * @memberof CalendarDate
   */
  zoneinfo?: TimeZone
  /**
   *
   * @type {number}
   * @memberof CalendarDate
   */
  zoneOffset?: number
  /**
   *
   * @type {number}
   * @memberof CalendarDate
   */
  daylightSaving?: number
  /**
   *
   * @type {boolean}
   * @memberof CalendarDate
   */
  forceStandardTime?: boolean
  /**
   *
   * @type {Locale}
   * @memberof CalendarDate
   */
  locale?: Locale
  /**
   *
   * @type {number}
   * @memberof CalendarDate
   */
  timeOfDay?: number
  /**
   *
   * @type {boolean}
   * @memberof CalendarDate
   */
  standardTime?: boolean
  /**
   *
   * @type {boolean}
   * @memberof CalendarDate
   */
  daylightTime?: boolean
  /**
   *
   * @type {TimeZone}
   * @memberof CalendarDate
   */
  zone?: TimeZone
}
/**
 *
 * @export
 * @interface Era
 */
export interface Era {
  /**
   *
   * @type {string}
   * @memberof Era
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof Era
   */
  abbr?: string
  /**
   *
   * @type {number}
   * @memberof Era
   */
  since?: number
  /**
   *
   * @type {CalendarDate}
   * @memberof Era
   */
  sinceDate?: CalendarDate
  /**
   *
   * @type {boolean}
   * @memberof Era
   */
  localTime?: boolean
  /**
   *
   * @type {number}
   * @memberof Era
   */
  hash?: number
  /**
   *
   * @type {string}
   * @memberof Era
   */
  abbreviation?: string
}
/**
 *
 * @export
 * @interface HandleAndPassword
 */
export interface HandleAndPassword {
  /**
   *
   * @type {string}
   * @memberof HandleAndPassword
   */
  handle: string
  /**
   *
   * @type {string}
   * @memberof HandleAndPassword
   */
  password: string
}
/**
 *
 * @export
 * @enum {string}
 */

export const Language = {
  En: "en",
  Nl: "nl",
  Hu: "hu",
} as const

export type Language = typeof Language[keyof typeof Language]

/**
 *
 * @export
 * @interface Locale
 */
export interface Locale {
  /**
   *
   * @type {string}
   * @memberof Locale
   */
  language?: string
  /**
   *
   * @type {string}
   * @memberof Locale
   */
  script?: string
  /**
   *
   * @type {string}
   * @memberof Locale
   */
  country?: string
  /**
   *
   * @type {string}
   * @memberof Locale
   */
  variant?: string
  /**
   *
   * @type {string[]}
   * @memberof Locale
   */
  extensionKeys?: string[]
  /**
   *
   * @type {string[]}
   * @memberof Locale
   */
  unicodeLocaleAttributes?: string[]
  /**
   *
   * @type {string[]}
   * @memberof Locale
   */
  unicodeLocaleKeys?: string[]
  /**
   *
   * @type {string}
   * @memberof Locale
   */
  iSO3Language?: string
  /**
   *
   * @type {string}
   * @memberof Locale
   */
  iSO3Country?: string
  /**
   *
   * @type {string}
   * @memberof Locale
   */
  displayLanguage?: string
  /**
   *
   * @type {string}
   * @memberof Locale
   */
  displayScript?: string
  /**
   *
   * @type {string}
   * @memberof Locale
   */
  displayCountry?: string
  /**
   *
   * @type {string}
   * @memberof Locale
   */
  displayVariant?: string
  /**
   *
   * @type {string}
   * @memberof Locale
   */
  displayName?: string
}
/**
 *
 * @export
 * @enum {string}
 */

export const Mode = {
  OldWords: "OLD_WORDS",
  NewWords: "NEW_WORDS",
  WeakWords: "WEAK_WORDS",
} as const

export type Mode = typeof Mode[keyof typeof Mode]

/**
 *
 * @export
 * @interface ModelDate
 */
export interface ModelDate {
  /**
   *
   * @type {Era}
   * @memberof ModelDate
   */
  era?: Era
  /**
   *
   * @type {number}
   * @memberof ModelDate
   */
  year?: number
  /**
   *
   * @type {number}
   * @memberof ModelDate
   */
  month?: number
  /**
   *
   * @type {number}
   * @memberof ModelDate
   */
  dayOfMonth?: number
  /**
   *
   * @type {number}
   * @memberof ModelDate
   */
  dayOfWeek?: number
  /**
   *
   * @type {boolean}
   * @memberof ModelDate
   */
  leapYear?: boolean
  /**
   *
   * @type {number}
   * @memberof ModelDate
   */
  hours?: number
  /**
   *
   * @type {number}
   * @memberof ModelDate
   */
  minutes?: number
  /**
   *
   * @type {number}
   * @memberof ModelDate
   */
  seconds?: number
  /**
   *
   * @type {number}
   * @memberof ModelDate
   */
  millis?: number
  /**
   *
   * @type {number}
   * @memberof ModelDate
   */
  fraction?: number
  /**
   *
   * @type {boolean}
   * @memberof ModelDate
   */
  normalized?: boolean
  /**
   *
   * @type {TimeZone}
   * @memberof ModelDate
   */
  zoneinfo?: TimeZone
  /**
   *
   * @type {number}
   * @memberof ModelDate
   */
  zoneOffset?: number
  /**
   *
   * @type {number}
   * @memberof ModelDate
   */
  daylightSaving?: number
  /**
   *
   * @type {boolean}
   * @memberof ModelDate
   */
  forceStandardTime?: boolean
  /**
   *
   * @type {Locale}
   * @memberof ModelDate
   */
  locale?: Locale
  /**
   *
   * @type {number}
   * @memberof ModelDate
   */
  timeOfDay?: number
  /**
   *
   * @type {boolean}
   * @memberof ModelDate
   */
  standardTime?: boolean
  /**
   *
   * @type {boolean}
   * @memberof ModelDate
   */
  daylightTime?: boolean
  /**
   *
   * @type {TimeZone}
   * @memberof ModelDate
   */
  zone?: TimeZone
  /**
   *
   * @type {number}
   * @memberof ModelDate
   */
  cachedYear?: number
  /**
   *
   * @type {number}
   * @memberof ModelDate
   */
  cachedFixedDateJan1?: number
  /**
   *
   * @type {number}
   * @memberof ModelDate
   */
  cachedFixedDateNextJan1?: number
  /**
   *
   * @type {number}
   * @memberof ModelDate
   */
  normalizedYear?: number
  /**
   *
   * @type {number}
   * @memberof ModelDate
   */
  cachedJan1?: number
}
/**
 *
 * @export
 * @interface Query
 */
export interface Query {
  /**
   *
   * @type {string}
   * @memberof Query
   */
  ownerUUID: string
  /**
   *
   * @type {Language}
   * @memberof Query
   */
  known: Language
  /**
   *
   * @type {Language}
   * @memberof Query
   */
  learnt: Language
  /**
   *
   * @type {Mode}
   * @memberof Query
   */
  mode: Mode
  /**
   *
   * @type {number}
   * @memberof Query
   */
  amount: number
}
/**
 *
 * @export
 * @interface TimeZone
 */
export interface TimeZone {
  /**
   *
   * @type {string}
   * @memberof TimeZone
   */
  ID?: string
  /**
   *
   * @type {number}
   * @memberof TimeZone
   */
  rawOffset?: number
  /**
   *
   * @type {string}
   * @memberof TimeZone
   */
  iD?: string
  /**
   *
   * @type {string}
   * @memberof TimeZone
   */
  displayName?: string
  /**
   *
   * @type {number}
   * @memberof TimeZone
   */
  dSTSavings?: number
}
/**
 *
 * @export
 * @interface Timestamp
 */
export interface Timestamp {
  /**
   *
   * @type {number}
   * @memberof Timestamp
   * @deprecated
   */
  year?: number
  /**
   *
   * @type {number}
   * @memberof Timestamp
   * @deprecated
   */
  month?: number
  /**
   *
   * @type {number}
   * @memberof Timestamp
   * @deprecated
   */
  date?: number
  /**
   *
   * @type {number}
   * @memberof Timestamp
   * @deprecated
   */
  day?: number
  /**
   *
   * @type {number}
   * @memberof Timestamp
   * @deprecated
   */
  hours?: number
  /**
   *
   * @type {number}
   * @memberof Timestamp
   * @deprecated
   */
  minutes?: number
  /**
   *
   * @type {number}
   * @memberof Timestamp
   * @deprecated
   */
  seconds?: number
  /**
   *
   * @type {number}
   * @memberof Timestamp
   */
  timeImpl?: number
  /**
   *
   * @type {number}
   * @memberof Timestamp
   * @deprecated
   */
  timezoneOffset?: number
  /**
   *
   * @type {ModelDate}
   * @memberof Timestamp
   */
  calendarDate?: ModelDate
  /**
   *
   * @type {number}
   * @memberof Timestamp
   */
  nanos?: number
  /**
   *
   * @type {number}
   * @memberof Timestamp
   */
  time?: number
}
/**
 *
 * @export
 * @enum {string}
 */

export const Type = {
  ManualFeedback: "MANUAL_FEEDBACK",
  QChoice4: "Q_CHOICE_4",
  QChoice4BadAlt: "Q_CHOICE_4_BAD_ALT",
  QFreeText: "Q_FREE_TEXT",
} as const

export type Type = typeof Type[keyof typeof Type]

/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {string}
   * @memberof User
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  handle: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  uuid: string
}
/**
 *
 * @export
 * @interface UserPost
 */
export interface UserPost {
  /**
   *
   * @type {string}
   * @memberof UserPost
   */
  name: string
  /**
   *
   * @type {string}
   * @memberof UserPost
   */
  handle: string
}
/**
 *
 * @export
 * @interface UserUpdate
 */
export interface UserUpdate {
  /**
   *
   * @type {string}
   * @memberof UserUpdate
   */
  uuid: string
  /**
   *
   * @type {string}
   * @memberof UserUpdate
   */
  name: string
}
/**
 *
 * @export
 * @interface VocabItem
 */
export interface VocabItem {
  /**
   *
   * @type {number}
   * @memberof VocabItem
   */
  id: number
  /**
   *
   * @type {Word}
   * @memberof VocabItem
   */
  known: Word
  /**
   *
   * @type {Word}
   * @memberof VocabItem
   */
  learnt: Word
  /**
   *
   * @type {number}
   * @memberof VocabItem
   */
  confidence: number
  /**
   *
   * @type {VocabItemEventEntity}
   * @memberof VocabItem
   */
  lastDirectEvent?: VocabItemEventEntity
}
/**
 *
 * @export
 * @interface VocabItemEventEntity
 */
export interface VocabItemEventEntity {
  /**
   *
   * @type {number}
   * @memberof VocabItemEventEntity
   */
  id?: number
  /**
   *
   * @type {Timestamp}
   * @memberof VocabItemEventEntity
   */
  ts?: Timestamp
  /**
   *
   * @type {boolean}
   * @memberof VocabItemEventEntity
   */
  success?: boolean
  /**
   *
   * @type {boolean}
   * @memberof VocabItemEventEntity
   */
  direct?: boolean
  /**
   *
   * @type {Type}
   * @memberof VocabItemEventEntity
   */
  type?: Type
  /**
   *
   * @type {number}
   * @memberof VocabItemEventEntity
   */
  confidenceSnapshot?: number
}
/**
 *
 * @export
 * @interface VocabItemEventResponse
 */
export interface VocabItemEventResponse {
  /**
   *
   * @type {number}
   * @memberof VocabItemEventResponse
   */
  confidence: number
}
/**
 *
 * @export
 * @interface VocabItemPayload
 */
export interface VocabItemPayload {
  /**
   *
   * @type {Word}
   * @memberof VocabItemPayload
   */
  known: Word
  /**
   *
   * @type {Word}
   * @memberof VocabItemPayload
   */
  learnt: Word
}
/**
 *
 * @export
 * @interface VocabSet
 */
export interface VocabSet {
  /**
   *
   * @type {number}
   * @memberof VocabSet
   */
  id: number
  /**
   *
   * @type {boolean}
   * @memberof VocabSet
   */
  upToDate: boolean
  /**
   *
   * @type {VocabSetState}
   * @memberof VocabSet
   */
  state: VocabSetState
  /**
   *
   * @type {Language}
   * @memberof VocabSet
   */
  known: Language
  /**
   *
   * @type {Language}
   * @memberof VocabSet
   */
  learnt: Language
}
/**
 *
 * @export
 * @interface VocabSetPayload
 */
export interface VocabSetPayload {
  /**
   *
   * @type {Language}
   * @memberof VocabSetPayload
   */
  known: Language
  /**
   *
   * @type {Language}
   * @memberof VocabSetPayload
   */
  learnt: Language
  /**
   *
   * @type {VocabSetState}
   * @memberof VocabSetPayload
   */
  state: VocabSetState
}
/**
 *
 * @export
 * @enum {string}
 */

export const VocabSetState = {
  Hidden: "HIDDEN",
  Disabled: "DISABLED",
  Enabled: "ENABLED",
} as const

export type VocabSetState = typeof VocabSetState[keyof typeof VocabSetState]

/**
 *
 * @export
 * @interface Word
 */
export interface Word {
  /**
   *
   * @type {string}
   * @memberof Word
   */
  word: string
  /**
   *
   * @type {string}
   * @memberof Word
   */
  bracketInfo?: string
}

/**
 * UserResourceApi - axios parameter creator
 * @export
 */
export const UserResourceApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {HandleAndPassword} [handleAndPassword]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userAuthPost: async (
      handleAndPassword?: HandleAndPassword,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/user/-/auth`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        handleAndPassword,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {UserPost} [userPost]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userPost: async (
      userPost?: UserPost,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/user`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        userPost,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {UserUpdate} [userUpdate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userPut: async (
      userUpdate?: UserUpdate,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/user`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        userUpdate,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userUuidPost: async (
      body?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/user/-/uuid`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * UserResourceApi - functional programming interface
 * @export
 */
export const UserResourceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    UserResourceApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {HandleAndPassword} [handleAndPassword]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userAuthPost(
      handleAndPassword?: HandleAndPassword,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userAuthPost(
        handleAndPassword,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {UserPost} [userPost]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userPost(
      userPost?: UserPost,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userPost(
        userPost,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {UserUpdate} [userUpdate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userPut(
      userUpdate?: UserUpdate,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userPut(
        userUpdate,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userUuidPost(
      body?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userUuidPost(
        body,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * UserResourceApi - factory interface
 * @export
 */
export const UserResourceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = UserResourceApiFp(configuration)
  return {
    /**
     *
     * @param {HandleAndPassword} [handleAndPassword]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userAuthPost(
      handleAndPassword?: HandleAndPassword,
      options?: any
    ): AxiosPromise<User> {
      return localVarFp
        .userAuthPost(handleAndPassword, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @param {UserPost} [userPost]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userPost(userPost?: UserPost, options?: any): AxiosPromise<User> {
      return localVarFp
        .userPost(userPost, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @param {UserUpdate} [userUpdate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userPut(userUpdate?: UserUpdate, options?: any): AxiosPromise<User> {
      return localVarFp
        .userPut(userUpdate, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userUuidPost(body?: string, options?: any): AxiosPromise<User> {
      return localVarFp
        .userUuidPost(body, options)
        .then(request => request(axios, basePath))
    },
  }
}

/**
 * UserResourceApi - object-oriented interface
 * @export
 * @class UserResourceApi
 * @extends {BaseAPI}
 */
export class UserResourceApi extends BaseAPI {
  /**
   *
   * @param {HandleAndPassword} [handleAndPassword]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserResourceApi
   */
  public userAuthPost(
    handleAndPassword?: HandleAndPassword,
    options?: AxiosRequestConfig
  ) {
    return UserResourceApiFp(this.configuration)
      .userAuthPost(handleAndPassword, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {UserPost} [userPost]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserResourceApi
   */
  public userPost(userPost?: UserPost, options?: AxiosRequestConfig) {
    return UserResourceApiFp(this.configuration)
      .userPost(userPost, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {UserUpdate} [userUpdate]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserResourceApi
   */
  public userPut(userUpdate?: UserUpdate, options?: AxiosRequestConfig) {
    return UserResourceApiFp(this.configuration)
      .userPut(userUpdate, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserResourceApi
   */
  public userUuidPost(body?: string, options?: AxiosRequestConfig) {
    return UserResourceApiFp(this.configuration)
      .userUuidPost(body, options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * VocabItemEventRegisterApi - axios parameter creator
 * @export
 */
export const VocabItemEventRegisterApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {number} vocabItemId
     * @param {VocabItemEventEntity} [vocabItemEventEntity]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vocabItemVocabItemIdEventPost: async (
      vocabItemId: number,
      vocabItemEventEntity?: VocabItemEventEntity,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'vocabItemId' is not null or undefined
      assertParamExists(
        "vocabItemVocabItemIdEventPost",
        "vocabItemId",
        vocabItemId
      )
      const localVarPath = `/vocab-item/{vocab-item-id}/event`.replace(
        `{${"vocab-item-id"}}`,
        encodeURIComponent(String(vocabItemId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        vocabItemEventEntity,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * VocabItemEventRegisterApi - functional programming interface
 * @export
 */
export const VocabItemEventRegisterApiFp = function (
  configuration?: Configuration
) {
  const localVarAxiosParamCreator =
    VocabItemEventRegisterApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {number} vocabItemId
     * @param {VocabItemEventEntity} [vocabItemEventEntity]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async vocabItemVocabItemIdEventPost(
      vocabItemId: number,
      vocabItemEventEntity?: VocabItemEventEntity,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<VocabItemEventResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.vocabItemVocabItemIdEventPost(
          vocabItemId,
          vocabItemEventEntity,
          options
        )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * VocabItemEventRegisterApi - factory interface
 * @export
 */
export const VocabItemEventRegisterApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = VocabItemEventRegisterApiFp(configuration)
  return {
    /**
     *
     * @param {number} vocabItemId
     * @param {VocabItemEventEntity} [vocabItemEventEntity]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vocabItemVocabItemIdEventPost(
      vocabItemId: number,
      vocabItemEventEntity?: VocabItemEventEntity,
      options?: any
    ): AxiosPromise<VocabItemEventResponse> {
      return localVarFp
        .vocabItemVocabItemIdEventPost(
          vocabItemId,
          vocabItemEventEntity,
          options
        )
        .then(request => request(axios, basePath))
    },
  }
}

/**
 * VocabItemEventRegisterApi - object-oriented interface
 * @export
 * @class VocabItemEventRegisterApi
 * @extends {BaseAPI}
 */
export class VocabItemEventRegisterApi extends BaseAPI {
  /**
   *
   * @param {number} vocabItemId
   * @param {VocabItemEventEntity} [vocabItemEventEntity]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VocabItemEventRegisterApi
   */
  public vocabItemVocabItemIdEventPost(
    vocabItemId: number,
    vocabItemEventEntity?: VocabItemEventEntity,
    options?: AxiosRequestConfig
  ) {
    return VocabItemEventRegisterApiFp(this.configuration)
      .vocabItemVocabItemIdEventPost(vocabItemId, vocabItemEventEntity, options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * VocabItemResourceApi - axios parameter creator
 * @export
 */
export const VocabItemResourceApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {number} [parent]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vocabItemGet: async (
      parent?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/vocab-item`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (parent !== undefined) {
        localVarQueryParameter["parent"] = parent
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {number} [parent]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vocabItemIdDelete: async (
      id: number,
      parent?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("vocabItemIdDelete", "id", id)
      const localVarPath = `/vocab-item/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (parent !== undefined) {
        localVarQueryParameter["parent"] = parent
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {number} [parent]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vocabItemIdGet: async (
      id: number,
      parent?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("vocabItemIdGet", "id", id)
      const localVarPath = `/vocab-item/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (parent !== undefined) {
        localVarQueryParameter["parent"] = parent
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {number} [parent]
     * @param {VocabItemPayload} [vocabItemPayload]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vocabItemIdPut: async (
      id: number,
      parent?: number,
      vocabItemPayload?: VocabItemPayload,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("vocabItemIdPut", "id", id)
      const localVarPath = `/vocab-item/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (parent !== undefined) {
        localVarQueryParameter["parent"] = parent
      }

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        vocabItemPayload,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} [parent]
     * @param {VocabItemPayload} [vocabItemPayload]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vocabItemPost: async (
      parent?: number,
      vocabItemPayload?: VocabItemPayload,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/vocab-item`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (parent !== undefined) {
        localVarQueryParameter["parent"] = parent
      }

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        vocabItemPayload,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * VocabItemResourceApi - functional programming interface
 * @export
 */
export const VocabItemResourceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    VocabItemResourceApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {number} [parent]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async vocabItemGet(
      parent?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<VocabItem>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.vocabItemGet(
        parent,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {number} [parent]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async vocabItemIdDelete(
      id: number,
      parent?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.vocabItemIdDelete(id, parent, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {number} [parent]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async vocabItemIdGet(
      id: number,
      parent?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<VocabItem>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.vocabItemIdGet(
        id,
        parent,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {number} [parent]
     * @param {VocabItemPayload} [vocabItemPayload]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async vocabItemIdPut(
      id: number,
      parent?: number,
      vocabItemPayload?: VocabItemPayload,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<VocabItem>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.vocabItemIdPut(
        id,
        parent,
        vocabItemPayload,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} [parent]
     * @param {VocabItemPayload} [vocabItemPayload]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async vocabItemPost(
      parent?: number,
      vocabItemPayload?: VocabItemPayload,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<VocabItem>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.vocabItemPost(
        parent,
        vocabItemPayload,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * VocabItemResourceApi - factory interface
 * @export
 */
export const VocabItemResourceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = VocabItemResourceApiFp(configuration)
  return {
    /**
     *
     * @param {number} [parent]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vocabItemGet(
      parent?: number,
      options?: any
    ): AxiosPromise<Array<VocabItem>> {
      return localVarFp
        .vocabItemGet(parent, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {number} [parent]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vocabItemIdDelete(
      id: number,
      parent?: number,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .vocabItemIdDelete(id, parent, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {number} [parent]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vocabItemIdGet(
      id: number,
      parent?: number,
      options?: any
    ): AxiosPromise<VocabItem> {
      return localVarFp
        .vocabItemIdGet(id, parent, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {number} [parent]
     * @param {VocabItemPayload} [vocabItemPayload]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vocabItemIdPut(
      id: number,
      parent?: number,
      vocabItemPayload?: VocabItemPayload,
      options?: any
    ): AxiosPromise<VocabItem> {
      return localVarFp
        .vocabItemIdPut(id, parent, vocabItemPayload, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @param {number} [parent]
     * @param {VocabItemPayload} [vocabItemPayload]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vocabItemPost(
      parent?: number,
      vocabItemPayload?: VocabItemPayload,
      options?: any
    ): AxiosPromise<VocabItem> {
      return localVarFp
        .vocabItemPost(parent, vocabItemPayload, options)
        .then(request => request(axios, basePath))
    },
  }
}

/**
 * VocabItemResourceApi - object-oriented interface
 * @export
 * @class VocabItemResourceApi
 * @extends {BaseAPI}
 */
export class VocabItemResourceApi extends BaseAPI {
  /**
   *
   * @param {number} [parent]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VocabItemResourceApi
   */
  public vocabItemGet(parent?: number, options?: AxiosRequestConfig) {
    return VocabItemResourceApiFp(this.configuration)
      .vocabItemGet(parent, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {number} [parent]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VocabItemResourceApi
   */
  public vocabItemIdDelete(
    id: number,
    parent?: number,
    options?: AxiosRequestConfig
  ) {
    return VocabItemResourceApiFp(this.configuration)
      .vocabItemIdDelete(id, parent, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {number} [parent]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VocabItemResourceApi
   */
  public vocabItemIdGet(
    id: number,
    parent?: number,
    options?: AxiosRequestConfig
  ) {
    return VocabItemResourceApiFp(this.configuration)
      .vocabItemIdGet(id, parent, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {number} [parent]
   * @param {VocabItemPayload} [vocabItemPayload]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VocabItemResourceApi
   */
  public vocabItemIdPut(
    id: number,
    parent?: number,
    vocabItemPayload?: VocabItemPayload,
    options?: AxiosRequestConfig
  ) {
    return VocabItemResourceApiFp(this.configuration)
      .vocabItemIdPut(id, parent, vocabItemPayload, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} [parent]
   * @param {VocabItemPayload} [vocabItemPayload]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VocabItemResourceApi
   */
  public vocabItemPost(
    parent?: number,
    vocabItemPayload?: VocabItemPayload,
    options?: AxiosRequestConfig
  ) {
    return VocabItemResourceApiFp(this.configuration)
      .vocabItemPost(parent, vocabItemPayload, options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * VocabSetResourceApi - axios parameter creator
 * @export
 */
export const VocabSetResourceApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {string} [parent]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vocabSetGet: async (
      parent?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/vocab-set`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (parent !== undefined) {
        localVarQueryParameter["parent"] = parent
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {string} [parent]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vocabSetIdDelete: async (
      id: number,
      parent?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("vocabSetIdDelete", "id", id)
      const localVarPath = `/vocab-set/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (parent !== undefined) {
        localVarQueryParameter["parent"] = parent
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {string} [parent]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vocabSetIdGet: async (
      id: number,
      parent?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("vocabSetIdGet", "id", id)
      const localVarPath = `/vocab-set/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (parent !== undefined) {
        localVarQueryParameter["parent"] = parent
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} id
     * @param {string} [parent]
     * @param {VocabSetPayload} [vocabSetPayload]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vocabSetIdPut: async (
      id: number,
      parent?: string,
      vocabSetPayload?: VocabSetPayload,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("vocabSetIdPut", "id", id)
      const localVarPath = `/vocab-set/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (parent !== undefined) {
        localVarQueryParameter["parent"] = parent
      }

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        vocabSetPayload,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {string} [parent]
     * @param {VocabSetPayload} [vocabSetPayload]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vocabSetPost: async (
      parent?: string,
      vocabSetPayload?: VocabSetPayload,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/vocab-set`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (parent !== undefined) {
        localVarQueryParameter["parent"] = parent
      }

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        vocabSetPayload,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * VocabSetResourceApi - functional programming interface
 * @export
 */
export const VocabSetResourceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    VocabSetResourceApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {string} [parent]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async vocabSetGet(
      parent?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<VocabSet>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.vocabSetGet(
        parent,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {string} [parent]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async vocabSetIdDelete(
      id: number,
      parent?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.vocabSetIdDelete(id, parent, options)
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {string} [parent]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async vocabSetIdGet(
      id: number,
      parent?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<VocabSet>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.vocabSetIdGet(
        id,
        parent,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {number} id
     * @param {string} [parent]
     * @param {VocabSetPayload} [vocabSetPayload]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async vocabSetIdPut(
      id: number,
      parent?: string,
      vocabSetPayload?: VocabSetPayload,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<VocabSet>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.vocabSetIdPut(
        id,
        parent,
        vocabSetPayload,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
    /**
     *
     * @param {string} [parent]
     * @param {VocabSetPayload} [vocabSetPayload]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async vocabSetPost(
      parent?: string,
      vocabSetPayload?: VocabSetPayload,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<VocabSet>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.vocabSetPost(
        parent,
        vocabSetPayload,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * VocabSetResourceApi - factory interface
 * @export
 */
export const VocabSetResourceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = VocabSetResourceApiFp(configuration)
  return {
    /**
     *
     * @param {string} [parent]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vocabSetGet(parent?: string, options?: any): AxiosPromise<Array<VocabSet>> {
      return localVarFp
        .vocabSetGet(parent, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {string} [parent]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vocabSetIdDelete(
      id: number,
      parent?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .vocabSetIdDelete(id, parent, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {string} [parent]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vocabSetIdGet(
      id: number,
      parent?: string,
      options?: any
    ): AxiosPromise<VocabSet> {
      return localVarFp
        .vocabSetIdGet(id, parent, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @param {number} id
     * @param {string} [parent]
     * @param {VocabSetPayload} [vocabSetPayload]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vocabSetIdPut(
      id: number,
      parent?: string,
      vocabSetPayload?: VocabSetPayload,
      options?: any
    ): AxiosPromise<VocabSet> {
      return localVarFp
        .vocabSetIdPut(id, parent, vocabSetPayload, options)
        .then(request => request(axios, basePath))
    },
    /**
     *
     * @param {string} [parent]
     * @param {VocabSetPayload} [vocabSetPayload]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    vocabSetPost(
      parent?: string,
      vocabSetPayload?: VocabSetPayload,
      options?: any
    ): AxiosPromise<VocabSet> {
      return localVarFp
        .vocabSetPost(parent, vocabSetPayload, options)
        .then(request => request(axios, basePath))
    },
  }
}

/**
 * VocabSetResourceApi - object-oriented interface
 * @export
 * @class VocabSetResourceApi
 * @extends {BaseAPI}
 */
export class VocabSetResourceApi extends BaseAPI {
  /**
   *
   * @param {string} [parent]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VocabSetResourceApi
   */
  public vocabSetGet(parent?: string, options?: AxiosRequestConfig) {
    return VocabSetResourceApiFp(this.configuration)
      .vocabSetGet(parent, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {string} [parent]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VocabSetResourceApi
   */
  public vocabSetIdDelete(
    id: number,
    parent?: string,
    options?: AxiosRequestConfig
  ) {
    return VocabSetResourceApiFp(this.configuration)
      .vocabSetIdDelete(id, parent, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {string} [parent]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VocabSetResourceApi
   */
  public vocabSetIdGet(
    id: number,
    parent?: string,
    options?: AxiosRequestConfig
  ) {
    return VocabSetResourceApiFp(this.configuration)
      .vocabSetIdGet(id, parent, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {number} id
   * @param {string} [parent]
   * @param {VocabSetPayload} [vocabSetPayload]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VocabSetResourceApi
   */
  public vocabSetIdPut(
    id: number,
    parent?: string,
    vocabSetPayload?: VocabSetPayload,
    options?: AxiosRequestConfig
  ) {
    return VocabSetResourceApiFp(this.configuration)
      .vocabSetIdPut(id, parent, vocabSetPayload, options)
      .then(request => request(this.axios, this.basePath))
  }

  /**
   *
   * @param {string} [parent]
   * @param {VocabSetPayload} [vocabSetPayload]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VocabSetResourceApi
   */
  public vocabSetPost(
    parent?: string,
    vocabSetPayload?: VocabSetPayload,
    options?: AxiosRequestConfig
  ) {
    return VocabSetResourceApiFp(this.configuration)
      .vocabSetPost(parent, vocabSetPayload, options)
      .then(request => request(this.axios, this.basePath))
  }
}

/**
 * WordResourceApi - axios parameter creator
 * @export
 */
export const WordResourceApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {Query} [query]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    wordsPost: async (
      query?: Query,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/words`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter["Content-Type"] = "application/json"

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        query,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * WordResourceApi - functional programming interface
 * @export
 */
export const WordResourceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    WordResourceApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @param {Query} [query]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async wordsPost(
      query?: Query,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<VocabItem>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.wordsPost(
        query,
        options
      )
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      )
    },
  }
}

/**
 * WordResourceApi - factory interface
 * @export
 */
export const WordResourceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = WordResourceApiFp(configuration)
  return {
    /**
     *
     * @param {Query} [query]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    wordsPost(query?: Query, options?: any): AxiosPromise<Array<VocabItem>> {
      return localVarFp
        .wordsPost(query, options)
        .then(request => request(axios, basePath))
    },
  }
}

/**
 * WordResourceApi - object-oriented interface
 * @export
 * @class WordResourceApi
 * @extends {BaseAPI}
 */
export class WordResourceApi extends BaseAPI {
  /**
   *
   * @param {Query} [query]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WordResourceApi
   */
  public wordsPost(query?: Query, options?: AxiosRequestConfig) {
    return WordResourceApiFp(this.configuration)
      .wordsPost(query, options)
      .then(request => request(this.axios, this.basePath))
  }
}
